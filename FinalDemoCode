/*------------------------------------------------EEE3099S LINE FOLLOWER ROBOT----------------------
 * Title: 		EEE3099S LINE FOLLOWER ROBOT
 * Authors: 		Mic Rosato, Kai Brown, Jack Forrest, Tapiwa Courtz
 * Date Created:	19/09/2019
 * Last Modified:	23/09/2019
*/
//------------------------------------------------Included Libraries--------------------------------
#include "stm32f0xx.h"
#include <stdio.h>
#include <string.h>
/*------------------------------------------------I/O Explanation-----------------------------------
Sensors: (inputs)
Sensor 1 (outer right) = PB12
Sensor 2 (inner right) = PB13
Sensor 3 (middle) = PB14
Sensor 4 (inner left right) = PB15
Sensor 5 (outer left) = PA8
Sensor 6 (back) = PA9

Motor Channels: (outputs) -DO NOT ENABLE FORWARD AND BACK TOGETHER
Right Motor: PA0 = forward, PA1 = back
Left Motor: PA5 = forward, PA6 = back

SW0: Reset (pin 7)
SW1: PB10 (input) (needs Pull up - switch connects to ground)
LED0: PB1
*/
//------------------------------------------------Variables ----------------------------------------
//Defines
typedef int bool;
#define true 1
#define false 0
//Logic variables
int LorR = 0; //0 is left, 1 is right
int numTurn = 0;
int numPress = 0;
bool moving = false;
// Algorithm variables
int west = 1;
int north = 2;
int east = 3;
int south = 4;
int turn=0;
int direction = north;
int Path[100]={0};
int pathLength = 1;
//motor commands
int AllOutputsLow = ~(GPIO_ODR_0|GPIO_ODR_1|GPIO_ODR_5|GPIO_ODR_6); //and with GPIOA_ODR before new command
int RightMotorForward = GPIO_ODR_0; //Shrivel left
int RightMotorBack = GPIO_ODR_1;
int LeftMotorForward = GPIO_ODR_5; //shrivel right
int LeftMotorBack = GPIO_ODR_6;
int TurnMotorsRight = GPIO_ODR_5|GPIO_ODR_1;
int TurnMotorsLeft = GPIO_ODR_6|GPIO_ODR_0;
int MotorsReverse = GPIO_ODR_1|GPIO_ODR_6;
int MotorsForward = GPIO_ODR_0|GPIO_ODR_5;
//sensor commands
int S1 = GPIO_IDR_12;
int S2 = GPIO_IDR_13;
int S3 = GPIO_IDR_14;
int S4 = GPIO_IDR_15;
int S5 = GPIO_IDR_8;
int S6 = GPIO_IDR_9;
int AllInputsLowA = GPIO_IDR_8|GPIO_IDR_9;
int AllInputsLowB = GPIO_IDR_12|GPIO_IDR_8|GPIO_IDR_8|GPIO_IDR_8;
//Decide Function inputs
int Sen1;
int Sen3;
int Sen5;
//Switch and LED
int SW1 = GPIO_IDR_10;
int LED = GPIO_ODR_1;

// --------------------------------------------------Function declarations-------------------------
void init_GPIO(void);
void init_pwm(void);
void init_EXTI(void);
void init_NVIC(void);
void turnLeft(void);
void turnRight(void);
void straight(void);
void turnStraight();
void turnAround (void);
void endMaze(void);
void stop(void);
void delay(int);
void AdjustRight(void);
void AdjustLeft(void);
void decide(int, int, int, int, int, int);
void endMaze();
void New_Direction(int);
void Solve();
void Follow();
// --------------------------------------------------MAIN-------------------------------------------
int main (void){
   	init_GPIO();
	init_pwm();
    while(1){
        if (!(GPIOB->IDR & GPIO_IDR_10)){      //if button on PB10 pressed (goes low)
            moving = true;
            LorR=0;
            numPress++;
            numTurn = 0;
            GPIOB->ODR &= ~LED;
        }
        else if (!(GPIOB->IDR & GPIO_IDR_11)){ //
        	moving = true;
        	LorR=1;
			numPress++;
			numTurn = 0;
            GPIOB->ODR &= ~LED;
        }
        while(moving ==true){ //on first LHR
            if ((GPIOB->IDR & S2)&&(GPIOB->IDR & S3)){                             //Adjust Right &&!(GPIOB->IDR & S4)
                AdjustRight();
            }
            if ((GPIOB->IDR &S4)&&(GPIOB->IDR & S3)){                              //Adjust Left &&!(GPIOB->IDR & S2)
                AdjustLeft();
            }
            if ((GPIOB->IDR &S1)||(GPIOA->IDR & S5)){           //if either side sensor goes high (will happen at all turns)
                delay(10);
                stop();                                         //when one sensor is high stop
                if(GPIOB->IDR & S1){Sen1 = 1;}else{Sen1 = 0;}   //read in right sensor and convert to bool
                if(GPIOA->IDR & S5){Sen5 = 1;}else{Sen5 = 0;}   // read in left sensor and convert to bool
                straight(); //go forward for a bit
                delay(98);  //go forward for a bit
                stop();
                if ((GPIOB->IDR & S1)&&(GPIOB->IDR & S2)&&(GPIOB->IDR & S3)&&(GPIOB -> IDR & S4)&&(GPIOA -> IDR & S5)){
                	endMaze();
                }
                else{
                	if(GPIOB->IDR & S3){Sen3 = 1;}else{Sen3 = 0;}   // read in front sensor and convert to bool
                	decide(Sen5, Sen3, Sen1, LorR, numPress, numTurn);                       //make turning decision
                	numTurn++;
                }
            }
            else if ((~GPIOB->IDR & S1)&&(~GPIOB->IDR & S2)&&(~GPIOB->IDR & S3)&&(~GPIOB -> IDR & S4)&&(~GPIOA -> IDR & S5)){ //dead end 00000
                delay(5);
                stop();                                         //stop at the point where all are low
                if(GPIOB->IDR & S1){Sen1 = 1;}else{Sen1 = 0;}   //read in all sensors and convert to bool
                if(GPIOB->IDR & S3){Sen3 = 1;}else{Sen3 = 0;}
                if(GPIOA->IDR & S5){Sen5 = 1;}else{Sen5 = 0;}	//convert binary to boolean
                decide(Sen5, Sen3, Sen1, LorR, numPress, numTurn);
                numTurn++;
            }
            else{
            	straight();
            }
        }
	}
}

//--------------------------------------------DECIDE---------------------------------------------------------------------
void decide(int sensor5, int sensor3, int sensor1, int LorR, int numPress, int numTurn){
	if (numPress > 1){	//racing
		Follow();
	}
	else{
		if (sensor5 && !sensor3 && !sensor1){//left turn only 100
			turnLeft();
			turn = -1;
			New_Direction(turn);
			Solve();
		}
		else if (!sensor5 && sensor3 && sensor1){//right straight 011
			if (LorR == 0){
				turnStraight();
				turn = 0;
				New_Direction(turn);
				Solve();
			}	// favor straight over right
			else {
				turnRight();
				turn = 1;
				New_Direction(turn);
				Solve();
			}  // favor right over straight
		}
		else if (!sensor5 && !sensor3 && sensor1){//right turn only 001
			turnRight();
			turn = 1;
			New_Direction(turn);
			Solve();
		}
		else if (sensor5 && sensor3 && !sensor1){//left straight  110
			if (LorR == 0){
				turnLeft();
				turn = -1;
				New_Direction(turn);
				Solve();
			}	// favor left over straight
			else {
				turnStraight();
				turn = 0;
				New_Direction(turn);
				Solve();
			}  // favor straight over left
		}
		else if (sensor5 && sensor3 && sensor1){//4-way 111
			if (LorR == 0){
				turnLeft();
				turn = -1;
				New_Direction(turn);
				Solve();
			}	// favor left
			else {
				turnRight();
				turn = 1;
				New_Direction(turn);
				Solve();
			}  // favor right
		}
		else if (!sensor5 && !sensor3 && !sensor1){//dead-end 000
			turnAround();
			turn = 2;
			New_Direction(turn);
			Solve();
		}
		else if (sensor5 && !sensor3 && sensor1){//T junction 101
			if (LorR == 0){
				turnLeft();
				turn = -1;
				New_Direction(turn);
				Solve();
			}	// favor left
			else {
				turnRight();
				turn = 1;
				New_Direction(turn);
				Solve();
			}  // favor right
		}
		else{ //shouldn't need this
			straight();
			turn = 0;
			New_Direction(turn);
			Solve();
		}
	}
}

//------------------------------------------TURN FUNCTIONS ---------------------------------------------------------
void stop(void){
	GPIOA ->ODR &=0;
	delay(50);
}
void straight(void){
	GPIOA ->ODR &= AllOutputsLow;
	GPIOA ->ODR |= MotorsForward ;
}
void turnStraight(void){
	GPIOA ->ODR &= AllOutputsLow;
	GPIOA ->ODR |= MotorsForward ;
	delay(30);
}

void AdjustRight(void){
	GPIOA ->ODR &= AllOutputsLow;
	GPIOA ->ODR |= LeftMotorForward;
}

void AdjustLeft(void){
	GPIOA ->ODR &= AllOutputsLow;
	GPIOA ->ODR |= RightMotorForward;
}

void turnLeft(void){
	GPIOA ->ODR &= AllOutputsLow;
 	GPIOA ->ODR |= TurnMotorsLeft;
 	delay(212);
 	stop();
}

void turnRight(void){
	GPIOA ->ODR &= AllOutputsLow;
 	GPIOA ->ODR |= TurnMotorsRight;
 	delay(212);
 	stop();
}

void turnAround(void){
	GPIOA ->ODR &= AllOutputsLow;
	GPIOA->ODR |= TurnMotorsRight;
	delay(432);
	stop();
}

void endMaze(void){
	moving= false;
	GPIOB->ODR |= LED;
}

void delay(int delay1){
	for (int i=0;i<=delay1;i++){
		for (int i=0;i<=5000;i++){
		}
	}
}

// ---------------------------------------------INIT GPIO-------------------------------------------
void init_GPIO(void)
{
	RCC->AHBENR |= RCC_AHBENR_GPIOBEN;//Enable clock on GPIOB
	RCC->AHBENR |= RCC_AHBENR_GPIOAEN;//Enable clock on GPIOA

	/* SENSORS */
	/* setting PA8, PA9 and PB 12-15 to inputs for sensor */
	GPIOA->MODER &=~(GPIO_MODER_MODER8|GPIO_MODER_MODER9);
    GPIOB->MODER &=~(GPIO_MODER_MODER12|GPIO_MODER_MODER13|GPIO_MODER_MODER14|GPIO_MODER_MODER15);
	/* pull down resistor for pin 8 and 9 of port A and pin 12-15 of Port B */
	GPIOA->PUPDR&=~(GPIO_PUPDR_PUPDR8|GPIO_PUPDR_PUPDR9);
	GPIOA->PUPDR|=(GPIO_PUPDR_PUPDR8_1|GPIO_PUPDR_PUPDR9_1);
    GPIOB->PUPDR&=~(GPIO_PUPDR_PUPDR12|GPIO_PUPDR_PUPDR13|GPIO_PUPDR_PUPDR14|GPIO_PUPDR_PUPDR15);
    GPIOB->PUPDR|=(GPIO_PUPDR_PUPDR12_1|GPIO_PUPDR_PUPDR13_1|GPIO_PUPDR_PUPDR14_1|GPIO_PUPDR_PUPDR15_1);

	/* Switch and LED */
	/* set switch PB10, PB11 to input*/
    GPIOB->MODER &=~(GPIO_MODER_MODER10);
    GPIOB->MODER &=~(GPIO_MODER_MODER11);
    /* set LED0 PB1 to output */
    GPIOB->MODER &=~(GPIO_MODER_MODER1);
    GPIOB->MODER |=(GPIO_MODER_MODER1_0);
	/* Pull-up resistor for start switch PB10 */
    GPIOB->PUPDR&=~(GPIO_PUPDR_PUPDR10);
    GPIOB->PUPDR|=(GPIO_PUPDR_PUPDR10_0);
    GPIOB->PUPDR&=~(GPIO_PUPDR_PUPDR11);
    GPIOB->PUPDR|=(GPIO_PUPDR_PUPDR11_0);

    /* Motor IC */
    /*set PA3, PA2 AF mode*/
	GPIOA ->MODER |= (GPIO_MODER_MODER2_1|GPIO_MODER_MODER3_1);
    /*set PA0,A1,A5,A6 to output mode*/
	GPIOA ->MODER |= (GPIO_MODER_MODER0_0|GPIO_MODER_MODER1_0|GPIO_MODER_MODER5_0|GPIO_MODER_MODER6_0);
	GPIOA ->ODR &= AllOutputsLow; //set all outputs low initially
}

// ---------------------------------------------INIT PWM--------------------------------------------
void init_pwm(void){
  	RCC->APB1ENR |= RCC_APB1ENR_TIM2EN;


  	GPIOA->AFR[1] |= (2 << (4*(3 - 8))); // PA3_AF = AF2 (ie: map to TIM2_CH3) EN1
  	GPIOA->AFR[1] |= (2 << (4*(2 - 8))); // PA2_AF = AF2 (ie: map to TIM2_CH4) EN2

  	TIM2->ARR = 8000;  // f = 1 KHz
  	// specify PWM mode: OCxM bits in CCMRx. We want mode 1
  	TIM2->CCMR2 |= (TIM_CCMR2_OC3M_2 | TIM_CCMR2_OC3M_1); // PWM Mode 1
  	TIM2->CCMR2 |= (TIM_CCMR2_OC4M_2 | TIM_CCMR2_OC4M_1); // PWM Mode 1
  	// set PWM percentages
  	TIM2->CCR3 =  100* 80; // Red = 20%
  	TIM2->CCR4 = 100 * 80; // Green = 90%

  	// enable the OC channels
  	TIM2->CCER |= TIM_CCER_CC3E;
  	TIM2->CCER |= TIM_CCER_CC4E;

  	TIM2->CR1 |= TIM_CR1_CEN; // counter enable
}
// ---------------------------------------------ALGORITHM--------------------------------------------
void New_Direction(int turn)
{
	if (turn = -1 && direction> 1)// left turn
	{
		direction = direction + turn;
	}elsif(turn = -1 && direction= 1){
		direction = 4; 
	}elsif(turn = 0){ // straight
		direction = direction;
	}elsif(turn = 1 && direction<4) // right turn
		direction = direction+ turn;
	}elsif(turn = 1 && direction=4)
		direction = 1;
	}elsif(turn = 2 && direction= 4){ // turn around
		direction = 2;
	}elsif(turn = 2 && direction= 1){
		direction = 3;
	}elsif(turn = 2 && direction= 2){
		direction = 4;
	}elsif(turn = 2 && direction= 3){
		direction = 1;
	}else{direction = direction;}	
}

void Solve()
{
	global pathLength;
	global direction;
	int shortDone=0;
	if (pathLength < 3){
		path[pathLength] = direction;
		pathLength -= 1; 
		shortDone = 1;
	}elsif(path[pathLength-2] == 1 && path[pathLength-1]== 3 && shortDone ==0 ){
		path[pathLength-2] = path[pathLength];
		pathLength -= 2;
		shortDone = 1;
	}elsif(path[pathLength-2] == 3 && path[pathLength-1]== 1 && shortDone ==0 ){
		path[pathLength-2] = path[pathLength];
		pathLength -= 3;
		shortDone = 1;
	}elsif(path[pathLength-2] == 2 && path[pathLength-1]== 4 && shortDone ==0 ){
		path[pathLength-2] = path[pathLength];
		pathLength -= 3;
		shortDone = 1;
	}elsif(path[pathLength-2] == 4 && path[pathLength-1]== 2 && shortDone ==0 ){
		path[pathLength-2] = path[pathLength];
		pathLength -= 3;
		shortDone = 1;
	}else{
		path[pathLength] = direction;
		shortDone = 1;
	}
	pathLength ++;
}

void Follow()
{
	if(direction < Path[numTurn]){
		turnRight();
		turn = 1;
		New_Direction(turn);
	}
	if(direction > Path[numTurn]){
		turnLeft();
		turn = -1;
		New_Direction(turn);
	}
	if(direction == Path[numTurn]){
		turnStraight();
		turn = 0;
		New_Direction(turn);
	}
}

